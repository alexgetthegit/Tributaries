<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>WebXR • Toggle Handmade ↔ GLB</title>
  <style>
    html, body { margin:0; height:100%; background:#000; color:#fff; }
    #hud {
      position:fixed; top:8px; left:8px; background:rgba(0,0,0,.5);
      padding:6px 10px; border-radius:8px; font:12px system-ui, sans-serif; line-height:1.35;
    }
    #hint {
      position:fixed; inset:auto 0 16px 0; display:flex; justify-content:center;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      pointer-events:none;
    }
    #hint .bubble {
      pointer-events:auto; background:rgba(0,0,0,.55); color:#fff;
      padding:10px 14px; border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,.25);
      font-size:14px
    }
    #hint .bubble button { margin-left:10px; padding:6px 10px; border:0; border-radius:8px; cursor:pointer }
    .hidden { display:none; }
  </style>
</head>
<body>
  <div id="hud">
    <div><b>Mode:</b> <span id="modeLabel">loading…</span> · Switch: <b>1</b>=Handmade, <b>2</b>=GLB</div>
    <div>Handmade: Texture pan <b>J/L</b> yaw, <b>I/K</b> tilt · Desktop: <b>W/A/S/D</b> + mouse look</div>
  </div>

  <!-- Hidden 360° sky video (used by handmade mode) -->
  <video id="pano" playsinline muted loop preload="metadata"
         crossorigin="anonymous" style="display:none"></video>

  <div id="hint">
    <div class="bubble">
      Click “Enable Mouse Look”, then use <b>W/A/S/D</b> (or arrows) to move · Press <b>Esc</b> to release
      <button id="lockBtn">Enable Mouse Look</button>
    </div>
  </div>

  <!-- Import map -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>

  <script type="module">
    import * as THREE from 'three';
    import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
    import { XRButton } from 'three/addons/webxr/XRButton.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // ===== Config =====
    const DEFAULT_MODE = 'handmade';          // 'handmade' or 'glb'
    const VIDEO_URL = 'https://pub-8cbedf6f909d4e39a938e2cee5080e7a.r2.dev/sky360.mp4';
    const GLB_URL   = 'models/world.glb';     // change if your file name/path differs

    // ===== Renderer / Scene / Camera =====
    const renderer = new THREE.WebGLRenderer({ antialias:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 1.5));
    renderer.setSize(innerWidth, innerHeight);
    renderer.xr.enabled = true;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(XRButton.createButton(renderer, { optionalFeatures:['local-floor','bounded-floor'] }));

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, innerWidth/innerHeight, 0.1, 2000);
    camera.position.set(0, 1.6, 0);

    // Shared lights
    scene.add(new THREE.HemisphereLight(0xbfd8ff, 0x202020, 0.6));

    // Top-level “layers”
    const handmadeGroup = new THREE.Group(); handmadeGroup.name = 'HandmadeGroup';
    const glbGroup = new THREE.Group(); glbGroup.name = 'GLBGroup';
    scene.add(handmadeGroup, glbGroup);

    // ====== Handmade scene (your current file) ======
    let skyMesh = null, skyTex = null;
    const panoEl = document.getElementById('pano');
    panoEl.src = VIDEO_URL;

    function makeCeilingDome(radius=50) {
      // top hemisphere: start at zenith (0), go down to horizon (PI/2)
      const g = new THREE.SphereGeometry(radius, 64, 32, 0, Math.PI*2, 0, Math.PI/2);
      g.scale(-1, 1, 1);
      return g;
    }

    function buildHandmadeScene(group) {
      // Floor (10×10 m @ y=0)
      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(10, 10),
        new THREE.MeshStandardMaterial({ color: 0x2f3338, roughness: 1.0 })
      );
      floor.rotation.x = -Math.PI / 2;
      floor.position.y = 0;
      group.add(floor);

      // Sky video (ceiling dome)
      function buildVideoSky(video) {
        skyTex = new THREE.VideoTexture(video);
        skyTex.colorSpace = THREE.SRGBColorSpace;
        skyTex.minFilter = THREE.LinearFilter;
        skyTex.magFilter = THREE.LinearFilter;
        skyTex.generateMipmaps = false;
        // Allow panning
        skyTex.wrapS = THREE.RepeatWrapping;
        skyTex.wrapT = THREE.ClampToEdgeWrapping;
        skyTex.center.set(0.5, 0.5);

        const mat = new THREE.MeshBasicMaterial({ map: skyTex, toneMapped:false });
        skyMesh = new THREE.Mesh(makeCeilingDome(50), mat);
        group.add(skyMesh);
      }

      async function tryStartVideo(){
        try { await panoEl.play(); } catch {}
        if (!skyMesh && !panoEl.paused) buildVideoSky(panoEl);
      }
      // kick off on click and XR start (only when handmade is visible)
      addEventListener('pointerdown', ()=>{ if(handmadeGroup.visible) tryStartVideo(); }, { once:true });
      renderer.xr.addEventListener('sessionstart', ()=>{ if(handmadeGroup.visible) tryStartVideo(); });
      document.addEventListener('visibilitychange', ()=> document.hidden ? panoEl.pause() : (handmadeGroup.visible && tryStartVideo()));

      // Keyboard panning for the sky texture
      addEventListener('keydown', (e)=>{
        if (!handmadeGroup.visible || !skyTex) return;
        const step = 0.01;
        switch (e.key.toLowerCase()) {
          case 'j': skyTex.offset.x = (skyTex.offset.x - step) % 1; break;
          case 'l': skyTex.offset.x = (skyTex.offset.x + step) % 1; break;
          case 'i': skyTex.offset.y = Math.min(1, skyTex.offset.y + step); break;
          case 'k': skyTex.offset.y = Math.max(0, skyTex.offset.y - step); break;
        }
      });

      // Helpful error hint
      panoEl.addEventListener('error', e=>{
        if (!handmadeGroup.visible) return;
        console.warn('Video failed to load. Check VIDEO_URL and R2 CORS/public settings.', e);
        console.warn('Direct-link test:', VIDEO_URL);
      });
    }

    // Build handmade now (we’ll show/hide via mode)
    buildHandmadeScene(handmadeGroup);

    // ====== GLB world loader ======
    let glbLoaded = false;
    async function loadGLBWorld(group) {
      if (glbLoaded) return;
      const loader = new GLTFLoader();
      loader.load(GLB_URL, (gltf)=>{
        const model = gltf.scene;
        // Optional: center on origin
        const box = new THREE.Box3().setFromObject(model);
        const center = box.getCenter(new THREE.Vector3());
        model.position.sub(center); // center model
        // Optional: scale to reasonable size (fits within ~10×10×5)
        const size = box.getSize(new THREE.Vector3());
        const target = new THREE.Vector3(10,5,10);
        const s = Math.min(target.x/(size.x||1), target.y/(size.y||1), target.z/(size.z||1));
        model.scale.setScalar(THREE.MathUtils.clamp(s, 0.01, 10));

        model.traverse(o=>{ o.castShadow = o.receiveShadow = true; });
        group.add(model);
        glbLoaded = true;
      }, undefined, (err)=> console.error('GLB load failed:', err));
    }

    // ====== Mode toggle (show/hide groups, handle video pause/resume) ======
    const modeLabel = document.getElementById('modeLabel');
    function setMode(mode){
      const m = (mode === 'glb') ? 'glb' : 'handmade';

      handmadeGroup.visible = (m === 'handmade');
      glbGroup.visible = (m === 'glb');

      modeLabel.textContent = (m === 'handmade') ? 'Handmade' : 'GLB';

      // manage sky video playback
      if (m === 'handmade') {
        // resume / build if needed
        if (panoEl.paused) { panoEl.play().catch(()=>{}); }
        if (!skyMesh && !panoEl.paused) {
          // safety: ensure sky exists
          const evt = new Event('pointerdown'); window.dispatchEvent(evt);
        }
      } else {
        // pause when hidden
        if (!panoEl.paused) panoEl.pause();
        // ensure GLB is loaded
        loadGLBWorld(glbGroup);
      }
    }

    // Default mode
    setMode(DEFAULT_MODE);

    // Keyboard switchers
    addEventListener('keydown', (e)=>{
      if (e.key === '1') setMode('handmade');
      if (e.key === '2') setMode('glb');
    });

    // ====== Desktop first-person controls (WASD + mouse look) ======
    const controls = new PointerLockControls(camera, renderer.domElement);
    const hint = document.getElementById('hint');
    const lockBtn = document.getElementById('lockBtn');

    lockBtn.addEventListener('click', () => { controls.lock(); });
    controls.addEventListener('lock',  () => hint.classList.add('hidden'));
    controls.addEventListener('unlock',()=> hint.classList.remove('hidden'));

    const keys = { forward:false, back:false, left:false, right:false };
    addEventListener('keydown', (e)=>{
      switch(e.code){
        case 'KeyW': case 'ArrowUp':    keys.forward = true; break;
        case 'KeyS': case 'ArrowDown':  keys.back    = true; break;
        case 'KeyA': case 'ArrowLeft':  keys.left    = true; break;
        case 'KeyD': case 'ArrowRight': keys.right   = true; break;
      }
    });
    addEventListener('keyup', (e)=>{
      switch(e.code){
        case 'KeyW': case 'ArrowUp':    keys.forward = false; break;
        case 'KeyS': case 'ArrowDown':  keys.back    = false; break;
        case 'KeyA': case 'ArrowLeft':  keys.left    = false; break;
        case 'KeyD': case 'ArrowRight': keys.right   = false; break;
      }
    });

    const vel = new THREE.Vector3();
    const dir = new THREE.Vector3();
    const SPEED = 2.0, DAMP = 8.0, HALF = 25;

    function updateDesktopMovement(dt){
      if (!controls.isLocked) return;
      dir.set((+keys.right)-(+keys.left), 0, (+keys.back)-(+keys.forward)).normalize();
      if (dir.lengthSq()){
        const forward = new THREE.Vector3(); controls.getDirection(forward);
        forward.y = 0; forward.normalize();
        const right = new THREE.Vector3().crossVectors(forward, new THREE.Vector3(0,1,0)).negate();
        const wish = new THREE.Vector3().addScaledVector(forward, -dir.z).addScaledVector(right, dir.x).setLength(SPEED);
        vel.lerp(wish, Math.min(1, dt*DAMP));
      } else vel.lerp(new THREE.Vector3(), Math.min(1, dt*DAMP));

      const d = vel.clone().multiplyScalar(dt);
      controls.moveRight(d.x);
      controls.moveForward(d.z);

      const p = controls.getObject().position;
      p.x = THREE.MathUtils.clamp(p.x, -HALF, HALF);
      p.z = THREE.MathUtils.clamp(p.z, -HALF, HALF);
      p.y = 1.6;
    }

    // ====== Animate ======
    const clock = new THREE.Clock();
    renderer.setAnimationLoop(()=>{
      const dt = Math.min(0.05, clock.getDelta());
      if (!renderer.xr.isPresenting) updateDesktopMovement(dt);
      renderer.render(scene, camera);
    });

    // Resize
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
